###
# SPDX-License-Identifier: MPL-2.0
#
# Author: Bernd rederlechner <bernd.rederlechner@t-systems.com
#
# Run a customisation build for the "Master/Backport" customisation strategy
#
# Make sure to start the workflow manually on 'master'
# The workflow builds your personal customisation branch:
# Stable builds: `customisation-<github.actor>-nmc/<stable version>`
# master builds: `customisation-<github.actor>-master`
# For a pure check run, you can set the INPUT variable PUSH_RESULT to false.
#
# !!! ATTENTION !!! The build will have strange side effects and is effectively
# unusable if started on an already used customisation branch. MAKE SURE YOU DELETE
# THE customisation- branch BEFORE BUILD !!!
# 
# For details about Nextcloud workflows: https://github.com/nextcloud/.github
#
# Test call: act --container-architecture linux/amd64 --secret-file ../secrets.env --env-file ../nmc-master-build.env -j build-custom

name: MagentaCLOUD custom build strategy


on:
  workflow_dispatch:

env:
  TARGET_TRUNK: "master"
  TARGET_STABLE: "nmcstable/25.0.6"
  FETCH_DEPTH: 0
  # PUSH_RESULT:   ${{ vars.PUSH_RESULT || true }}
  # CUSTOM_REPO:   ${{ vars.CUSTOM_REPO || github.repository }}
  CUSTOM_REPO:   ${{ github.repository }}
  # CUSTOM_BRANCH: ${{ vars.CUSTOM_BRANCH || format('customisation-${0}-{1}', github.actor, env.TARGET_STABLE) }}
  CUSTOM_BRANCH: ${{ format('customisation-${0}-{1}', github.actor, env.TARGET_STABLE) }}
  PUSH_RESULT:   false
  BUILD_USER:    ${{ github.actor }}
  BUILD_EMAIL:   ${{ format('{0}@users.noreply.github.com', github.actor) }}
  BUILD_TOKEN:   ${{ secrets.GITHUB_TOKEN }}
  # BUILD_TOKEN: ${{ secrets.BUILD_TOKEN || secrets.GITHUB_TOKEN }}


jobs:
  build-custom:
    runs-on: ubuntu-latest
    steps:

      - name: "Find customisation candidates"
        uses: octokit/graphql-action@v2.x
        id: find_customisations
        env:
          GITHUB_TOKEN: ${{ env.BUILD_TOKEN }}
        with:
          query: |
            query findCustomisations($searchexpr: String!) {
              search(query: $searchexpr, type: ISSUE, first: 100) {
                edges {
                  node {
                    ... on PullRequest {
                      state
                      number
                      title
                      baseRefName
                      headRefName
                      mergeable
                      isDraft
                      url
                    }
                  }
                }
              }
            }
          searchexpr: "type:pr state:open repo:${{ env.CUSTOM_REPO }} base:${{ env.TARGET_TRUNK }} base:${{ env.TARGET_STABLE }} label:custom label:build-ready"
          # note that the search has OR semantice for base:, but AND semantice for label: !
          # see: https://docs.github.com/en/search-github/searching-on-github/searching-issues-and-pull-requests#search-by-label
      - id: customisations
        run: |
          pulls=$(echo '${{ steps.find_customisations.outputs.data }}' | jq -s '.[].search.edges | map(.node) | sort_by(.headRefName)')
          echo ::set-output name=pulls::$pulls

      - name: Picking backports
        id: pickbackports
        uses: actions/github-script@v6
        env:
          customisations: ${{ steps.customisations.outputs.pulls }}
          target_trunk: ${{ env.TARGET_TRUNK }}
          target_stable: ${{ env.TARGET_STABLE }}
        with:
          script: |
            const customisations = JSON.parse(process.env.customisations);
            const target_trunk   = process.env.target_trunk;
            const target_stable  = process.env.target_stable;

            function shuffleArray(array) {
                return array.reduce((acc, current, index) => {
                        const randomIndex = Math.floor(Math.random() * (index + 1));
                        [acc[index], acc[randomIndex]] = [acc[randomIndex], acc[index]];
                        return acc;
                    }, [...array]);
            }

            function isBackportFor(port, master) {
                if (( port.baseRefName === target_stable ) &&
                    ( master.baseRefName === target_trunk ) && 
                    ( port.headRefName.startsWith( master.headRefName ))) {
                    return true;  
                } else {
                    return false;
                }
            }

            var buildparts = [];
            var newerparts =[];

            for (cIdx=0; cIdx < customisations.length; cIdx++) {
                if (cIdx+1 < customisations.length) {
                    // detect master - backport pairs
                    if (isBackportFor( customisations[cIdx], customisations[cIdx+1] )) {
                        buildparts.push(customisations[cIdx]);
                        newerparts.push(customisations[cIdx+1]);
                        cIdx++;
                    } else if (isBackportFor( customisations[cIdx+1], customisations[cIdx] )) {
                        buildparts.push(customisations[cIdx+1]);
                        newerparts.push(customisations[cIdx]);
                        cIdx++;
                    } else {
                        // handle as single entry
                        buildparts.push(customisations[cIdx]);
                    }
                } else {
                    // handle as last entry
                    buildparts.push(customisations[cIdx]);
                }
            }
            core.setOutput('buildparts', JSON.stringify(shuffleArray(buildparts)) );
            core.setOutput('newerparts', JSON.stringify(shuffleArray(newerparts)) );
            return "";            

      # we exclude non-mergeable branches and exclude them from build
      - name: Check mergeability
        id: checkmergeable
        uses: actions/github-script@v6
        env:
          buildparts: ${{ steps.pickbackports.outputs.buildparts }}
        with:
          script: |
            const buildparts = JSON.parse(process.env.buildparts);
            var   mergeableparts = [];
            result = 0;
            buildparts.forEach( (buildpart) => {
                if ( buildpart.mergeable === 'MERGEABLE' ) {
                   mergeableparts.push(buildpart);
                } else {
                   notMergeableError= `${buildpart.mergeable} #${buildpart.number}: Incomplete package, lacking '${buildpart.title}'!`
                   core.error(notMergeableError);
                   result++;
                }
            });
            core.setOutput('mergeableparts', JSON.stringify(mergeableparts) );
            return result;

      - name: Checkout build repo
        uses: actions/checkout@v3
        with:
          repository: ${{ env.CUSTOM_REPO }}
          ref: ${{ env.TARGET_STABLE }}
          fetch-depth: ${{ env.FETCH_DEPTH }}
          token: ${{ secrets.BUILD_TOKEN }}

      # this works also with TARGET_STABLE as a branch OR tag
      - name: Prepare trunk build branch
        id: createcustombranch
        run: |
          if [ "$TARGET_TRUNK" == "$TARGET_STABLE" ]; then
              echo ::notice::TRUNK build '${{ env.TARGET_STABLE }}'
              git checkout -b $CUSTOM_BRANCH $TARGET_STABLE@HEAD
              echo ::output name=buildtype::trunk
          #elif [ $(git tag --contains "$TARGET_STABLE" 2>/dev/null) ]; then
          #    echo ::notice::TAGGED TRUNK build for '${{ env.TARGET_STABLE }}'
          #    git checkout -b $CUSTOM_BRANCH $TARGET_STABLE
          #    echo ::output name=buildtype::tag
          else
              echo ::notice::BACKPORT build for '${{ env.TARGET_STABLE }}'
              # git fetch origin $TARGET_STABLE
              git checkout -b $CUSTOM_BRANCH $TARGET_STABLE
              echo ::output name=buildtype::stable
          fi

      #- name: Detect obsolete backport candidates
      #  id: checkobsolete
      #  run: |
      #    git checkout $CUSTOM_BRANCH
      #    result=0
      #    newerparts=$(echo '${{ steps.pickbackports.outputs.newerparts }}' | jq -r '.[]')
      #    for newerpart in "$newerparts"
      #    do
      #        merge_result=0
      #        head=$(echo "$newerpart" | jq -r '.headRefName')
      #        base=$(echo "$newerpart" | jq -r '.baseRefName')        
      #        title=$(echo "$newerpart" | jq -r '.title')
      #        prnr=$(echo "$newerpart" | jq -r '.number')
      #    done

      - name: Merge customisations
        id: custommerge
        run: |
          function tmp_rebase {
              branch=$1
              base=$2
              prnr=$3
              title=$4
              copybranch=$branch-$GITHUB_RUN_ID

              git checkout $base
              git checkout $branch
              git branch --copy $branch $copybranch

              echo ::debug::"REBASE-$base #$prnr $copybranch"
              git checkout $CUSTOM_BRANCH
              git rebase --merge --onto $CUSTOM_BRANCH --fork-point $base $copybranch
              result=$?
              if [ $result = 0 ]; then
                  # if rebase is successful, the final merge must be able to fast-forward
                  echo ::debug::"FF-MERGE-$base #$prnr $copybranch"
                  git merge --ff-only --commit  -m "Rebase-FF-Merge #$prnr $title" $copybranch
                  result=$?
              else
                  git diff --diff-filter=U ORIG_HEAD $CUSTOM_BRANCH
                  git rebase --abort
              fi

              git checkout $CUSTOM_BRANCH
              git branch -D $copybranch
              return $result
          }
        
          function merge {
              branch=$1
              base=$2
              prnr=$3
              title=$4

              # git fetch origin $branch
              git checkout $base
              git checkout $branch
              git checkout $CUSTOM_BRANCH

              echo ::debug::"MERGE-$base #$prnr $branch"
              # do test merge first
              git merge --commit -m "Merge #$prnr $title" $branch
              if [ $? != 0 ]; then
                  result=$?
                  git diff --diff-filter=U ORIG_HEAD $CUSTOM_BRANCH
                  git merge --abort
                  return $result
              fi
              return 0
          }

          # some settings are mandatory for commits
          git config user.name $BUILD_USER
          git config user.email $BUILD_EMAIL

          # start merging/rebasing
          # disable fast-fail as we always want to process all PR
          set +e
          result=0
          buildtype='${{ steps.createcustombranch.outputs.buildtype }}'
          echo '${{ steps.checkmergeable.outputs.mergeableparts }}' | jq -c -r '.[] | @json' | \
          while IFS= read -r mergepull; do
              merge_result=0
              head=$(echo "$mergepull" | jq -r '.headRefName')
              base=$(echo "$mergepull" | jq -r '.baseRefName')        
              title=$(echo "$mergepull" | jq -r '.title')
              prnr=$(echo "$mergepull" | jq -r '.number')
              echo ::group::"$head(type:$base) >>> '${{ env.CUSTOM_BRANCH }}'"
              echo ::debug::$mergepull
              if [ "$buildtype" == "trunk" ]; then
                  # only trunk customisations branched from trunk
                  # TODO: may require rebase of customisations to current master first
                  merge "$head" "$base" "$prnr" "$title"
                  merge_result=$?
              elif [ "$buildtype" == "tag" ]; then
                  # only trunk customisations, but shifted to an (older branch) - rebase
                  tmp_rebase "$head" "$base" "$prnr" "$title"
                  merge_result=$?
              else
                  # same behavior used for buildtypes tags and stable
                  # stable implements backport picking
                  if [ "$base" == "$TARGET_STABLE" ]; then
                      # backports are rooted at the same point as the customisation branch - merge
                      merge "$head" "$base" "$prnr" "$title"
                      merge_result=$?
                  else
                      # trunk customisations must be rebased
                      tmp_rebase "$head" "$base" "$prnr" "$title"
                      merge_result=$?
                  fi
              fi
              if [ $merge_result -ne 0 ]; then
                  echo ::error::"FAILED CUSTOMISATION #$prnr $head(type: $base): $title!"
                  (( result++ ))
              fi
              echo ::endgroup::
          done
          set -e
          echo ::output name=result::$result
          # exit $result

### PUSH result (optional)
    - name: Push '${{ env.CUSTOM_BRANCH }}'
      id: pushcustomisation        
      run: |
        if [ $PUSH_RESULT == true ]; then
            git push origin $CUSTOM_BRANCH
        fi

        
### Generation of additional artefacts (css, webpacks, start here)
#   See also `command-compile.yml`. All of this will be release-packaged,
#   but nothing should be checked in.

      - name: Detect working node and npm engines version
        uses: skjnldsv/read-package-engines-version-actions@v1
        id: package-engines-versions
        with:
          fallbackNode: '^12'
          fallbackNpm: '^6'

      - name: Setup node ${{ steps.package-engines-versions.outputs.nodeVersion }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ steps.package-engines-versions.outputs.nodeVersion }}
          cache: npm

      - name: Setup npm ${{ steps.package-engines-versions.outputs.npmVersion }}
        run: npm i -g npm@"${{ steps.package-engines-versions.outputs.npmVersion }}"

      - name: Install dependencies & build
        run: |
          npm ci
          npm run build --if-present

      - name: Build css
        run: npm run --if-present sass

      - name: Build css icons
        run: npm run --if-present sass:icons



### Final statistics
# incomplete or not... always check workflow result report!
      - name: Build summary
        id: summary
        if: ${{ always() }}
        run: |
          errors=$((${{ steps.checkmergeable.outputs.result || 1 }} + ${{ steps.custommerge.outputs.result || 1 }}))
          warnings=$((${{ steps.checkobsolete.outputs.result  || 0 }})) 
          if [ $errors > 0 ]; then
              echo ::error::"Customisation ERRORS: $errors, WARNINGS: $warnings"
          elif [ $warnings > 0 ]; then
              echo ::warning::"Customisation Errors: 0, WARNINGS: $warnings"
          fi

